import { EventBus } from './EventBus';
import { TransactionExecutor } from './TransactionExecutor';
export class ContextThrottleService {
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    constructor() {
        this.interval = 0;
        this.throttled = true;
        this.contextThrottleMap = new Map();
    }
    static getInstance() {
        if (!ContextThrottleService.instance) {
            ContextThrottleService.instance = new ContextThrottleService();
        }
        return ContextThrottleService.instance;
    }
    getWithInitThrottleInfoByName(contextName, contextValue) {
        if (!this.contextThrottleMap.has(contextName)) {
            const contextData = {
                prevValue: null,
                throttledValue: contextValue,
                lastUpdateTimestamp: 0,
                updateTimerId: 0,
            };
            this.contextThrottleMap.set(contextName, contextData);
        }
        return this.contextThrottleMap.get(contextName);
    }
    getTimeUntilNextUpdate(lastUpdateTimestamp) {
        const timeSinceLastUpdate = Date.now() - lastUpdateTimestamp;
        const delayUntilNextUpdate = this.interval - timeSinceLastUpdate;
        return delayUntilNextUpdate;
    }
    updateContextValue(contextName, newValue) {
        const contextData = this.getWithInitThrottleInfoByName(contextName, newValue);
        if (newValue === contextData.throttledValue) {
            return;
        }
        contextData.prevValue = contextData.throttledValue;
        contextData.lastUpdateTimestamp = Date.now();
        contextData.throttledValue = newValue;
        EventBus.broadcast(contextName, [contextData.throttledValue, contextData.prevValue]);
    }
    throttleUpdateContextValue(contextName, newValue) {
        const contextData = this.getWithInitThrottleInfoByName(contextName, newValue);
        clearTimeout(contextData.updateTimerId);
        if (TransactionExecutor.isRunSyncActive) {
            return;
        }
        const lastUpdateTimestamp = contextData.lastUpdateTimestamp;
        const timeUntilNextUpdate = this.getTimeUntilNextUpdate(lastUpdateTimestamp);
        if (timeUntilNextUpdate <= 0) {
            this.updateContextValue(contextName, newValue);
        }
        else {
            contextData.updateTimerId = setTimeout(() => {
                this.updateContextValue(contextName, newValue);
            }, timeUntilNextUpdate);
        }
    }
    static triggerContextUpdate(contextName, newValue) {
        const throttledService = ContextThrottleService.getInstance();
        const contextData = throttledService.getWithInitThrottleInfoByName(contextName, newValue);
        if (newValue === contextData.throttledValue) {
            return;
        }
        if (!throttledService.throttled && !TransactionExecutor.isRunSyncActive) {
            throttledService.updateContextValue(contextName, newValue);
        }
        else {
            throttledService.throttleUpdateContextValue(contextName, newValue);
        }
    }
    static retrieveContextInfo(contextName, contextValue) {
        const throttledService = ContextThrottleService.getInstance();
        const { prevValue, throttledValue } = throttledService.getWithInitThrottleInfoByName(contextName, contextValue);
        return { prevValue, throttledValue };
    }
    static updateThrottledServiceSettings(settings) {
        const throttledService = ContextThrottleService.getInstance();
        throttledService.interval = settings.interval;
        throttledService.throttled = settings.throttled;
    }
}
//# sourceMappingURL=ContextThrottleService.js.map